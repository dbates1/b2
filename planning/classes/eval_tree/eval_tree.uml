@startuml
title Eval_tree Class 





	
	Node <|-- BinaryOperator
	Node <|-- UnaryOperator
	Node <|-- N_aryOperator
	Node <|-- Symbol
	
	N_aryOperator <|-- Plus
	N_aryOperator <|-- Minus
	N_aryOperator <|-- Times
	BinaryOperator <|-- Divide
	UnaryOperator <|-- Negate
	UnaryOperator <|-- Exp
	UnaryOperator <|-- Log
	UnaryOperator <|-- Sine
	UnaryOperator <|-- Cosine
	N_aryOperator <|-- UserDefined
	
	Symbol <|-- Variable
	Symbol <|-- PathVariable
	Symbol <|-- ExplicitParameter
	Symbol <|-- ImplicitParameter
	Symbol <|-- Subfunction
	Symbol <|-- Number	
	 
	 
	 
	
	interface Node {
		disallow empty instantiation?  
		this might be achieved by pure virtualism
		--public--
            	+{abstract} virtual SetPrecision(int prec)
            	+{abstract} virtual Evaluate() //Returns Symbol?
            	+{abstract} virtual String()
            	+{abstract} virtual addLeaf(Node* leaf)
        --private--      	
            	-Node()  private so that empty construction prohibited.  
            	this may help protect against errors in parsing
	}
	
	
	
	
	
	interface BinaryOperator {
		--public--
		virtual addLeaf(Node* leaf)
		--private--
		-Node* leftnode_
		-Node* rightnode_
	}
	
	interface UnaryOperator {
		--public--
		virtual addLeaf(Node* leaf)
		--private--
		-Node* node_
	}
	
	interface N_aryOperator {
		--public--
		virtual addLeaf(Node* leaf)
		--private--
		-std::vector<Node*> nodes_
	}
	interface Symbol {
	shared (?) pointer to the appropriate array at the system level
	how do we mark whether we intend to point at the actual value V or the derivative value dV??
	(For example, for f=x*y, we will have an eval_tree for df, i.e., x*dy + y*dx. ) 
	(Similarly, if x and y in the previous line are subfuctions, we need to point at the partial there somehow.)
	}

	
	
	
	
	
	
	class Plus {
		
	}
	
	class Minus {
		
	}
	
	class Negate {
		
	}
	
	class Times {
		
	}
	
	
	class Divide {
		
	}


	
	
	
	


@enduml
